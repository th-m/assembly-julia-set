<html><head></head><body><h1>writeHeader</h1>

<p>Write an assembly language function to write the header for a PPM
file to a buffer. More information about PPM files is available
here:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Netpbm_format">http://en.wikipedia.org/wiki/Netpbm_format</a></li>
</ul>

<p>For this function, the important part is the header, which has a
simple format:</p>

<pre><code>P3
xsize ysize
colormax
</code></pre>

<p>The “P3” is hard-coded, and signals the format in use (this is
called a magic value). The xsize and ysize values are integers
written out as plain text, and indicate the size of the image in
pixels. The colormax value tells the maximum color value for each
color channel (red, green, and blue), and is hard-coded at 255 for
our purposes.</p>

<p>For a 1024×768 image, the header would be:</p>

<pre><code>P3
1024 768
255
</code></pre>

<p>Which is the string: &#34;P3\n1024 768\n255\n&#34;</p>

<p>Your job is to write that header into a buffer, and return the
number of bytes written.</p>

<p>The function will take three parameters:</p>

<pre><code>writeHeader(buffer, xsize, ysize)
</code></pre>

<p>and return the number of bytes written to the buffer.</p>

<h2>Registers</h2>

<p>Your implementation of <code>writeHeader</code> will make calls to <code>itoa</code>.
To prepare for a call to a function (<code>itoa</code> in this case), you
should place the first parameter value in r0 and the second in r1.
Then make the function call using:</p>

<pre><code>bl  itoa
</code></pre>

<p>When <code>itoa</code> returns, you should assume that any valus in r0–r3, r12,
and r14 have been overwritten. If you have values stored in these
caller-saved registers, you must save them before making the
function call. There are two basic approaches to this problem:</p>

<ol>
<li><p>Pick call-saved registers and use those instead. At the
beginning of your function, you need to push the old
contents of those registers to the stack, and you need to
pop them again at the end before returning. In between, you can
use them freely, and assume that their values remain consistent
across function calls (since any function you call will save the
value and restore it just like you are doing).</p></li>

<li><p>Use the caller-saved registers, but save the values before
making the function call and restore them afterward. In this
approach, you push the values to the stack immediately before
making a function call, and pop them off the stack right after.
This does not replace your need to save callee-saved registers
that you plan to use, it is just another occasion to spill
register values onto the stack for temporary storage.</p></li>
</ol>

<h2>Testing</h2>

<p>To test your code as a standalone program, use the <code>_start</code> block
included in <code>start.s</code>.</p>
</body></html>