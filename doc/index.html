<html><head></head><body><h1>calcPixel</h1>

<p><code>mandel</code> works on floating point coordinates, but you must generate
an image with discrete pixels. In the next step you will calculate
points based on their location in a 256×256 image centered at the
origin. You will also convert the number of iterations into a shade
of gray.</p>

<p>Once this step is complete, you will have the functionality required
to compute a pixel color for each point in a complete image.</p>

<h2>The parameters</h2>

<p>To simplify the computation, you will assume that the image to be
generated is 256×256 pixels, and it will compute a Mandelbrot image
centered at the origin with 0.25 magnification. We will save the
details for the next project, but for now this means that you can
convert a pixel coordinate (a column and row number) to complex
plane coordinates (x and y float values) as follows:</p>

<ul>
<li>x = (column - 128) / (255.0 / 4.0)</li>
<li>y = -(row - 128) / (255.0 / 4.0)</li>
</ul>

<h2>The code</h2>

<p>In <code>calcpixel.s</code>, write the function calcPixel, which should work
as follows:</p>

<ul>
<li><code>calcPixel(maxIterations, column, row)</code> → <code>rgb</code></li>
</ul>

<p><code>calcPixel</code> converts the column and row numbers into <em>x</em> and <em>y</em>
coordinates as indicated above, then calls <code>mandel</code> to compute the
number of iterations. It then passes the number of iterations to
<code>getColor</code> (which is provided) to get an RGB color value.</p>

<p>Since <code>calcPixel</code> needs to call <code>mandel</code>, it must pass double values
as parameters. Just as <code>mandel</code> expects its first two double
parameters to be in d0 and d1 when it is called, <code>calcPixel</code> must
put those parameters in those registers before calling <code>mandel</code>.</p>

<p><code>getColor</code> is a simple function that copies its input value (the
number of iterations) into the red, green, and blue channels of a
single RGB value, resulting in a shade of gray. A pixel with few
iterations will be a dark shade of gray, and one with close to 255
iterations will be very close to white. This function is a
placeholder—in a later project this function will look up a color
from a palette.</p>

<p>Note that both <em>x</em> and <em>y</em> require division with a divisor of (255.0
/ 4.0). I suggest computing this value once at the beginning of
<code>calcPixel</code> (store it in one of the <code>d</code> registers) and then use it in
the computation of <em>x</em> and <em>y</em>.</p>

<p>Note: you should not need to modify <code>getcolor.s</code> at all for this
project.</p>

<h2>Testing</h2>

<p>A <code>start.s</code> file is provided. It will call <code>calcPixel</code> with a simple
test case, and will use the blue color value of the return value of
<code>calcPixel</code> as the exit status code. For the default test case, you
should expect an exit status code of 0. When you run the code with
<code>make run</code> or <code>grind action run</code>, make should report this as a
success. For example:</p>

<pre><code>$ make run
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp getcolor.s -o getcolor.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp calcpixel.s -o calcpixel.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp start.s -o start.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp mandel.s -o mandel.o
ld --fatal-warnings getcolor.o calcpixel.o start.o mandel.o
./a.out
</code></pre>

<p>When you get that much working, change <code>start.s</code> to load <code>col2</code> and
<code>row2</code> instead of <code>col1</code> and <code>row1</code> as the test values when it calls
<code>calcPixel</code>. The expected output for this case is 1 (the point at
that location escapes the threshold value after a single iteration),
so your code should return the color value <code>0x010101</code>. make will
report the blue part of this color as the error number:</p>

<pre><code>$ make run
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp getcolor.s -o getcolor.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp calcpixel.s -o calcpixel.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp start.s -o start.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp mandel.s -o mandel.o
ld --fatal-warnings getcolor.o calcpixel.o start.o mandel.o
./a.out
Makefile:20: recipe for target &#39;run&#39; failed
make: *** [run] Error 1
</code></pre>

<p>The third test case (use <code>col3</code> and <code>row3</code>) should return
<code>0x373737</code>, and the blue part of that color is <code>0x37</code> or decimal 55:</p>

<pre><code>$ make run
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp getcolor.s -o getcolor.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp calcpixel.s -o calcpixel.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp start.s -o start.o
as -g -march=armv6zk -mcpu=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp mandel.s -o mandel.o
ld --fatal-warnings getcolor.o calcpixel.o start.o mandel.o
./a.out
Makefile:20: recipe for target &#39;run&#39; failed
make: *** [run] Error 55
</code></pre>

<p>After you get all three of these test cases working, run the full
suite of tests.</p>
</body></html>